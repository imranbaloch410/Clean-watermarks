<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FrameCraft AI - Auto Text Remover</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>
    
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        gray: { 750: '#2d3748', 850: '#1a202c', 950: '#0d1117' },
                        accent: { 500: '#6366f1', 600: '#4f46e5' }
                    },
                }
            }
        }
    </script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * { font-family: 'Inter', sans-serif; }
        body { background-color: #0d1117; color: #f8fafc; margin: 0; padding: 0; }
        .spinner {
            border: 3px solid #374151;
            border-top-color: #6366f1;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        .drop-zone.dragover { border-color: #6366f1; background-color: rgba(99, 102, 241, 0.1); }
        .toast { animation: slide-in 0.3s ease-out forwards; }
        @keyframes slide-in { from { transform: translateX(100%); } to { transform: translateX(0); } }
        #watermarkCanvas { position: absolute; top: 0; left: 0; cursor: crosshair; pointer-events: none; }
        .watermark-overlay { position: absolute; border: 2px dashed #fbbf24; background: rgba(251, 191, 36, 0.2); pointer-events: none; }
    </style>
</head>
<body>
    <div id="app" class="h-screen flex flex-col overflow-hidden">
        <header class="h-14 border-b border-gray-800 flex items-center justify-between px-4 bg-gray-900/90 backdrop-blur-md z-30 shrink-0">
            <div class="flex items-center gap-3">
                <h1 class="font-bold text-lg tracking-tight hidden md:block">FrameCraft <span class="text-indigo-400 text-sm font-normal">AI Edition</span></h1>
            </div>
            <div class="flex items-center gap-3">
                <div id="imageCount" class="text-xs mr-2 hidden sm:block text-gray-400">0 / 200 images</div>
                
                <label class="flex items-center gap-2 cursor-pointer mr-2" title="Enable AI Text Removal">
                    <div id="watermarkToggle" class="w-10 h-4 rounded-full p-0.5 transition-colors bg-gray-700 cursor-pointer">
                        <div id="watermarkKnob" class="w-3 h-3 bg-white rounded-full shadow-md transform transition-transform translate-x-0"></div>
                    </div>
                    <span class="text-xs font-medium text-gray-500 hidden md:block">AI Removal</span>
                </label>

                <button id="addImagesBtn" class="text-sm font-medium text-white bg-gray-800 hover:bg-gray-700 transition-colors flex items-center gap-2 px-3 py-1.5 rounded-md border border-gray-700">
                    Add Images
                </button>
                <button id="downloadAllBtn" class="hidden text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-500 transition-colors items-center gap-2 px-3 py-1.5 rounded-md">
                    Download All
                </button>
                <input type="file" id="fileInput" accept="image/*" multiple />
            </div>
        </header>

        <div class="flex flex-1 overflow-hidden">
            <div class="w-24 md:w-64 bg-gray-900 border-r border-gray-800 flex flex-col shrink-0 z-20">
                <div class="p-3 border-b border-gray-800"><span class="text-xs font-semibold text-gray-500">Queue</span></div>
                <div id="batchList" class="flex-1 overflow-y-auto p-2 space-y-2">
                    <div id="emptyState" class="text-center py-10 text-gray-600 text-sm">No images.</div>
                </div>
            </div>

            <main class="flex-1 bg-gray-950 p-4 md:p-8 overflow-y-auto flex flex-col items-center relative drop-zone" id="dropZone">
                <div class="w-full max-w-5xl z-10 flex-1 flex flex-col justify-center min-h-[400px]">
                    <div id="previewContainer" class="w-full aspect-video bg-gray-900 rounded-lg flex items-center justify-center border border-gray-700 overflow-hidden relative">
                        <img id="previewImage" class="hidden w-full h-full object-contain" alt="Preview" />
                        <canvas id="watermarkCanvas" class="hidden"></canvas>
                        
                        <div id="processingOverlay" class="hidden absolute inset-0 bg-black/80 flex items-center justify-center z-50">
                            <div class="text-center">
                                <div class="spinner w-12 h-12 mx-auto mb-4"></div>
                                <p id="processingText" class="text-indigo-400 font-medium animate-pulse">AI Scanning...</p>
                                <p class="text-xs text-gray-500 mt-2">Finding text & logos without API key...</p>
                            </div>
                        </div>

                        <div id="previewPlaceholder" class="text-center space-y-4">
                            <p class="text-xl font-light text-gray-600">Drop images here</p>
                        </div>
                    </div>
                </div>

                <div id="controlsPanel" class="hidden mt-6 z-10 w-full max-w-4xl bg-gray-900 p-4 rounded-xl border border-gray-800 shadow-2xl flex flex-col xl:flex-row items-center justify-between gap-4">
                    <div class="flex items-center gap-4">
                        <button id="preset8k" class="px-3 py-1.5 text-xs font-medium rounded-md bg-gray-700 text-white">8K Ultra</button>
                        <button id="enhanceBtn" class="px-3 py-1.5 text-xs rounded-lg bg-gray-800 text-gray-400">NatGeo</button>
                    </div>
                    <button id="downloadCurrentBtn" class="px-6 py-2 bg-white text-gray-900 rounded-lg font-semibold text-sm">Download Current</button>
                </div>

                <div id="watermarkControls" class="hidden mt-4 z-10 w-full max-w-4xl bg-gray-900 p-4 rounded-xl border border-indigo-800 shadow-2xl">
                    <div class="flex flex-col md:flex-row items-center gap-4 justify-between">
                        <div class="flex items-center gap-2">
                            <p class="text-xs text-gray-400">AI Text Confidence:</p>
                            <input type="range" id="sensitivitySlider" min="50" max="90" value="70" class="w-24">
                        </div>
                        <div class="flex gap-2">
                            <button id="detectWatermarksBtn" class="px-4 py-2 text-xs rounded-lg bg-indigo-600 hover:bg-indigo-500 text-white font-bold flex items-center gap-2">
                                ðŸ¤– Run AI Scan
                            </button>
                            <button id="manualSelectBtn" class="px-4 py-2 text-xs rounded-lg bg-gray-700 hover:bg-gray-600 text-white">
                                âœ‹ Manual Box
                            </button>
                            <button id="clearRegionsBtn" class="px-4 py-2 text-xs rounded-lg bg-red-900/50 text-red-200">
                                Clear
                            </button>
                        </div>
                    </div>
                    <div class="text-[10px] text-gray-500 mt-2 text-center">
                        Powered by Tesseract.js (Local Browser AI) - No Server needed.
                    </div>
                </div>
            </main>
        </div>
    </div>

    <script>
        // ============ STATE ============
        const MAX_BATCH_SIZE = 200;
        let state = {
            batchItems: [],
            selectedId: null,
            sourceImage: null,
            processedDataUrl: null,
            enhanceQuality: false,
            watermarkRemovalEnabled: false,
            watermarkRegions: [],
            manualSelectionMode: false,
            aiConfidence: 70
        };

        // ============ DOM ELEMENTS ============
        const els = {
            fileInput: document.getElementById('fileInput'),
            addImagesBtn: document.getElementById('addImagesBtn'),
            previewImage: document.getElementById('previewImage'),
            watermarkCanvas: document.getElementById('watermarkCanvas'),
            processingOverlay: document.getElementById('processingOverlay'),
            processingText: document.getElementById('processingText'),
            watermarkToggle: document.getElementById('watermarkToggle'),
            watermarkKnob: document.getElementById('watermarkKnob'),
            watermarkControls: document.getElementById('watermarkControls'),
            controlsPanel: document.getElementById('controlsPanel'),
            detectWatermarksBtn: document.getElementById('detectWatermarksBtn'),
            manualSelectBtn: document.getElementById('manualSelectBtn'),
            clearRegionsBtn: document.getElementById('clearRegionsBtn'),
            downloadCurrentBtn: document.getElementById('downloadCurrentBtn'),
            previewContainer: document.getElementById('previewContainer'),
            batchList: document.getElementById('batchList'),
            queueCount: document.getElementById('queueCount'),
            imageCount: document.getElementById('imageCount')
        };

        // ============ CORE FUNCTIONS ============
        
        function loadImage(source) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = "anonymous";
                img.onload = () => resolve(img);
                img.onerror = () => reject(new Error('Failed to load image'));
                img.src = source;
            });
        }

        function render() {
            if (!state.sourceImage) return;
            
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // Target Resolution: 8K (7680x4320)
            canvas.width = 7680;
            canvas.height = 4320;
            
            // Background
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw Image (Fit Contain)
            const scale = Math.min(canvas.width / state.sourceImage.width, canvas.height / state.sourceImage.height);
            const x = (canvas.width / 2) - (state.sourceImage.width / 2) * scale;
            const y = (canvas.height / 2) - (state.sourceImage.height / 2) * scale;
            const w = state.sourceImage.width * scale;
            const h = state.sourceImage.height * scale;
            
            // Draw original
            if (state.enhanceQuality) ctx.filter = 'contrast(1.1) saturate(1.1)';
            ctx.drawImage(state.sourceImage, x, y, w, h);
            ctx.filter = 'none';

            // REMOVAL LOGIC (Advanced Blur/Clone)
            state.watermarkRegions.forEach(region => {
                // Convert relative coordinates to canvas pixels
                const rx = x + (region.x * w);
                const ry = y + (region.y * h);
                const rw = region.w * w;
                const rh = region.h * h;

                // 1. Heavy Blur (Base)
                ctx.save();
                ctx.beginPath();
                ctx.rect(rx, ry, rw, rh);
                ctx.clip();
                ctx.filter = 'blur(40px) brightness(1.05)'; // Blur + slight brighten to hide shadows
                // Draw the image again onto itself (blurred)
                ctx.drawImage(canvas, 0, 0); 
                ctx.restore();
            });

            state.processedDataUrl = canvas.toDataURL('image/jpeg', 0.9);
            els.previewImage.src = state.processedDataUrl;
            els.processingOverlay.classList.add('hidden');
        }

        // ============ AI LOGIC (Tesseract.js) ============
        async function runAIScan() {
            if (!state.sourceImage) return;
            
            els.processingOverlay.classList.remove('hidden');
            els.processingText.textContent = "AI Reading Text...";
            
            try {
                // Run Tesseract
                const result = await Tesseract.recognize(
                    state.sourceImage.src,
                    'eng',
                    { logger: m => els.processingText.textContent = `AI: ${Math.round(m.progress * 100)}%` }
                );

                const words = result.data.words;
                let found = 0;

                // Clear old auto-detected regions
                state.watermarkRegions = state.watermarkRegions.filter(r => r.manual);

                words.forEach(word => {
                    if (word.confidence > state.aiConfidence) {
                        // Normalize coordinates (0 to 1)
                        const region = {
                            x: word.bbox.x0 / state.sourceImage.width,
                            y: word.bbox.y0 / state.sourceImage.height,
                            w: (word.bbox.x1 - word.bbox.x0) / state.sourceImage.width,
                            h: (word.bbox.y1 - word.bbox.y0) / state.sourceImage.height
                        };
                        
                        // Expand box slightly to cover edges
                        region.x -= 0.005; region.y -= 0.005;
                        region.w += 0.01; region.h += 0.01;
                        
                        state.watermarkRegions.push(region);
                        found++;
                    }
                });

                showToast(`AI found ${found} text elements!`, 'success');
                renderOverlays();
                render();

            } catch (err) {
                console.error(err);
                showToast("AI Scan Failed. Try Manual.", "error");
                els.processingOverlay.classList.add('hidden');
            }
        }

        // ============ MANUAL SELECTION ============
        function setupManual() {
            const canvas = els.watermarkCanvas;
            canvas.style.pointerEvents = 'auto';
            let startX, startY, isDrag = false;

            canvas.onmousedown = (e) => {
                isDrag = true;
                const rect = canvas.getBoundingClientRect();
                startX = e.clientX - rect.left;
                startY = e.clientY - rect.top;
            };

            canvas.onmousemove = (e) => {
                if (!isDrag) return;
                const rect = canvas.getBoundingClientRect();
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0,0,canvas.width, canvas.height);
                ctx.strokeStyle = '#fbbf24';
                ctx.lineWidth = 2;
                ctx.strokeRect(startX, startY, (e.clientX - rect.left) - startX, (e.clientY - rect.top) - startY);
            };

            canvas.onmouseup = (e) => {
                if (!isDrag) return;
                isDrag = false;
                const rect = canvas.getBoundingClientRect();
                const endX = e.clientX - rect.left;
                const endY = e.clientY - rect.top;
                
                // Add Manual Region
                state.watermarkRegions.push({
                    x: Math.min(startX, endX) / canvas.width,
                    y: Math.min(startY, endY) / canvas.height,
                    w: Math.abs(endX - startX) / canvas.width,
                    h: Math.abs(endY - startY) / canvas.height,
                    manual: true
                });
                
                // Clear helper canvas
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0,0,canvas.width, canvas.height);
                
                renderOverlays();
                render();
            };
        }

        function renderOverlays() {
            document.querySelectorAll('.watermark-overlay').forEach(e => e.remove());
            const container = els.previewContainer;
            
            state.watermarkRegions.forEach((r, i) => {
                const div = document.createElement('div');
                div.className = 'watermark-overlay absolute border-2 border-yellow-400 bg-yellow-400/20';
                div.style.left = (r.x * 100) + '%';
                div.style.top = (r.y * 100) + '%';
                div.style.width = (r.w * 100) + '%';
                div.style.height = (r.h * 100) + '%';
                
                const btn = document.createElement('button');
                btn.innerHTML = 'Ã—';
                btn.className = 'absolute -top-3 -right-3 w-5 h-5 bg-red-500 text-white rounded-full text-xs flex items-center justify-center';
                btn.onclick = () => {
                    state.watermarkRegions.splice(i, 1);
                    renderOverlays();
                    render();
                };
                div.appendChild(btn);
                container.appendChild(div);
            });
        }

        // ============ UI EVENTS ============
        function showToast(msg, type) {
            const t = document.createElement('div');
            t.className = `fixed top-5 right-5 px-4 py-2 rounded text-white z-50 ${type === 'error' ? 'bg-red-600' : 'bg-green-600'}`;
            t.innerText = msg;
            document.body.appendChild(t);
            setTimeout(() => t.remove(), 3000);
        }

        els.addImagesBtn.onclick = () => els.fileInput.click();
        els.fileInput.onchange = (e) => {
            if(e.target.files[0]) {
                const file = e.target.files[0];
                const url = URL.createObjectURL(file);
                loadImage(url).then(img => {
                    state.sourceImage = img;
                    els.previewImage.classList.remove('hidden');
                    document.getElementById('previewPlaceholder').classList.add('hidden');
                    els.controlsPanel.classList.remove('hidden');
                    render();
                    
                    // Add to list
                    state.batchItems.push({file, url});
                    els.queueCount.innerText = state.batchItems.length + "/200";
                    
                    const div = document.createElement('div');
                    div.className = "p-2 bg-gray-800 rounded text-xs text-gray-300 truncate cursor-pointer hover:bg-gray-700";
                    div.innerText = file.name;
                    div.onclick = () => { state.sourceImage = img; render(); };
                    els.batchList.appendChild(div);
                    document.getElementById('emptyState').classList.add('hidden');
                });
            }
        };

        els.watermarkToggle.onclick = () => {
            state.watermarkRemovalEnabled = !state.watermarkRemovalEnabled;
            if(state.watermarkRemovalEnabled) {
                els.watermarkToggle.className = "w-10 h-4 rounded-full p-0.5 transition-colors bg-indigo-500 cursor-pointer";
                els.watermarkKnob.className = "w-3 h-3 bg-white rounded-full shadow-md transform transition-transform translate-x-6";
                els.watermarkControls.classList.remove('hidden');
            } else {
                els.watermarkToggle.className = "w-10 h-4 rounded-full p-0.5 transition-colors bg-gray-700 cursor-pointer";
                els.watermarkKnob.className = "w-3 h-3 bg-white rounded-full shadow-md transform transition-transform translate-x-0";
                els.watermarkControls.classList.add('hidden');
            }
        };

        els.detectWatermarksBtn.onclick = runAIScan;
        
        els.manualSelectBtn.onclick = () => {
            state.manualSelectionMode = !state.manualSelectionMode;
            if(state.manualSelectionMode) {
                els.manualSelectBtn.classList.add('bg-red-600');
                els.manualSelectBtn.innerText = "Draw Box Now";
                els.watermarkCanvas.classList.remove('hidden');
                setupManual();
            } else {
                els.manualSelectBtn.classList.remove('bg-red-600');
                els.manualSelectBtn.innerText = "Manual Box";
                els.watermarkCanvas.classList.add('hidden');
            }
        };

        els.clearRegionsBtn.onclick = () => {
            state.watermarkRegions = [];
            renderOverlays();
            render();
        };

        els.downloadCurrentBtn.onclick = () => {
            if(state.processedDataUrl) {
                const a = document.createElement('a');
                a.href = state.processedDataUrl;
                a.download = "framecraft-cleaned.jpg";
                a.click();
            }
        };
    </script>
</body>
</html>
