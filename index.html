
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FrameCraft 8K - Free Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        gray: {
                            750: '#2d3748',
                            850: '#1a202c',
                            950: '#0d1117',
                        },
                        accent: {
                            500: '#6366f1',
                            600: '#4f46e5',
                        }
                    },
                }
            }
        }
    </script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * { font-family: 'Inter', sans-serif; }
        body { background-color: #0d1117; color: #f8fafc; margin: 0; padding: 0; }
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #1e293b; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #64748b; }
        
        .spinner {
            border: 3px solid #374151;
            border-top-color: #6366f1;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        @keyframes fade-in {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .animate-fade-in {
            animation: fade-in 0.3s ease-out forwards;
        }
        
        .drop-zone {
            transition: all 0.3s ease;
        }
        
        .drop-zone.dragover {
            border-color: #6366f1;
            background-color: rgba(99, 102, 241, 0.1);
        }
        
        .toast {
            animation: slide-in 0.3s ease-out forwards;
        }
        
        @keyframes slide-in {
            from { transform: translateX(100%); }
            to { transform: translateX(0); }
        }

        /* Watermark selection overlay */
        #watermarkCanvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
            pointer-events: none;
        }
        
        .watermark-overlay {
            position: absolute;
            border: 2px dashed #fbbf24;
            background: rgba(251, 191, 36, 0.2);
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="app" class="h-screen flex flex-col overflow-hidden">
        <header class="h-14 border-b border-gray-800 flex items-center justify-between px-4 bg-gray-900/90 backdrop-blur-md z-30 shrink-0">
            <div class="flex items-center gap-3">
                <div class="w-7 h-7 bg-gradient-to-br from-indigo-500 to-purple-600 rounded-md flex items-center justify-center shadow-lg shadow-indigo-500/20">
                    <svg class="w-4 h-4 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                    </svg>
                </div>
                <h1 class="font-bold text-lg tracking-tight hidden md:block">FrameCraft <span class="text-indigo-400 text-sm font-normal">Free Edition</span></h1>
            </div>
            
            <div class="flex items-center gap-3">
                <div id="imageCount" class="text-xs mr-2 hidden sm:block text-gray-400">0 / 200 images</div>
                
                <label class="flex items-center gap-2 cursor-pointer mr-2 group" title="Enable watermark/logo removal">
                    <div id="watermarkToggle" class="w-10 h-4 rounded-full p-0.5 transition-colors bg-gray-700 cursor-pointer">
                        <div id="watermarkKnob" class="w-3 h-3 bg-white rounded-full shadow-md transform transition-transform translate-x-0"></div>
                    </div>
                    <span id="watermarkLabel" class="text-xs font-medium text-gray-500 group-hover:text-gray-400 hidden md:block">Watermark Removal</span>
                </label>
                
                <label class="flex items-center gap-2 cursor-pointer mr-2 group" title="Apply enhancement to all images">
                    <div id="batchEnhanceToggle" class="w-8 h-4 rounded-full p-0.5 transition-colors bg-gray-700 cursor-pointer">
                        <div id="batchEnhanceKnob" class="w-3 h-3 bg-white rounded-full shadow-md transform transition-transform translate-x-0"></div>
                    </div>
                    <span id="batchEnhanceLabel" class="text-xs font-medium text-gray-500 group-hover:text-gray-400">Batch Enhance</span>
                </label>
                
                <button id="addImagesBtn" class="text-sm font-medium text-white bg-gray-800 hover:bg-gray-700 transition-colors flex items-center gap-2 px-3 py-1.5 rounded-md border border-gray-700">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg>
                    Add Images
                </button>
                
                <button id="downloadAllBtn" class="hidden text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-500 transition-colors items-center gap-2 px-3 py-1.5 rounded-md shadow-md shadow-indigo-900/20">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg>
                    <span>Download All</span>
                </button>
                
                <input type="file" id="fileInput" accept="image/*" multiple />
            </div>
        </header>

        <div class="flex flex-1 overflow-hidden">
            <div class="w-24 md:w-64 bg-gray-900 border-r border-gray-800 flex flex-col shrink-0 z-20">
                <div class="p-3 border-b border-gray-800 flex justify-between items-center">
                    <span class="text-xs font-semibold text-gray-500 uppercase tracking-wider">Queue</span>
                    <span id="queueCount" class="text-[10px] bg-gray-800 text-gray-400 px-1.5 py-0.5 rounded">0/200</span>
                </div>
                <div id="batchList" class="flex-1 overflow-y-auto p-2 space-y-2">
                    <div id="emptyState" class="text-center py-10 text-gray-600 text-sm p-2">
                        No images. Add some to start.
                    </div>
                </div>
            </div>

            <main class="flex-1 bg-gray-950 p-4 md:p-8 overflow-y-auto flex flex-col items-center relative drop-zone" id="dropZone">
                <div class="absolute inset-0 z-0 opacity-[0.03]" style="background-image: radial-gradient(#fff 1px, transparent 1px); background-size: 20px 20px;"></div>

                <div class="w-full max-w-5xl z-10 flex-1 flex flex-col justify-center min-h-[400px]">
                    <div id="previewContainer" class="w-full aspect-video bg-gray-900 rounded-lg flex items-center justify-center text-gray-500 border border-gray-700 overflow-hidden relative">
                        <img id="previewImage" class="hidden w-full h-full object-contain" alt="Preview" />
                        <canvas id="watermarkCanvas" class="hidden"></canvas>
                        <div id="processingOverlay" class="hidden absolute inset-0 bg-black/50 flex items-center justify-center">
                            <div class="text-center">
                                <div class="spinner w-12 h-12 mx-auto mb-4"></div>
                                <p id="processingText" class="text-indigo-400 font-medium animate-pulse">Processing...</p>
                            </div>
                        </div>
                        <div id="dimensionBadge" class="hidden absolute top-4 right-4 bg-black/70 text-white text-xs px-2 py-1 rounded backdrop-blur-sm border border-white/10 font-mono">
                            7680 x 4320
                        </div>
                        <div id="enhanceBadge" class="hidden absolute top-4 right-16 bg-gradient-to-r from-amber-500 to-orange-600 text-white text-xs px-2 py-1 rounded shadow-lg font-bold tracking-wide flex items-center gap-1">
                            âœ¨ NatGeo
                        </div>
                        <div id="watermarkBadge" class="hidden absolute top-4 left-4 bg-gradient-to-r from-red-500 to-rose-600 text-white text-xs px-2 py-1 rounded shadow-lg font-bold tracking-wide flex items-center gap-1">
                            ðŸš« Watermark Removed
                        </div>
                        
                        <div id="previewPlaceholder" class="text-center space-y-4">
                            <svg class="w-16 h-16 mx-auto text-gray-700" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                            </svg>
                            <p class="text-xl font-light text-gray-600">Drop images here or click Add Images</p>
                            <p class="text-sm text-gray-700">Supports batch processing up to 200 images â€¢ Auto watermark removal available</p>
                        </div>
                    </div>
                </div>

                <div id="controlsPanel" class="hidden mt-6 z-10 w-full max-w-4xl bg-gray-900/ backdrop-blur p-4 rounded-xl border border-gray-800 shadow-2xl flex flex-col xl:flex-row items-center justify-between gap-4">
                    <div class="flex flex-col md:flex-row items-center gap-4 w-full xl:w-auto">
                        <div class="flex bg-gray-800 rounded-lg p-1 shrink-0">
                            <button id="preset8k" class="px-3 py-1.5 text-xs font-medium rounded-md transition-all bg-gray-700 text-white shadow-sm">
                                8K Ultra
                            </button>
                            <button id="presetYT" class="px-3 py-1.5 text-xs font-medium rounded-md transition-all text-gray-400 hover:text-gray-200">
                                YT Thumb
                            </button>
                        </div>

                        <div class="h-8 w-px bg-gray-700 hidden md:block"></div>

                        <div class="flex items-center gap-2 overflow-x-auto max-w-full pb-1 md:pb-0">
                            <button id="fitBlur" class="fit-btn px-3 py-1.5 text-xs rounded-lg transition-all bg-indigo-600 text-white shadow-lg shadow-indigo-900/50">
                                Blur Fill
                            </button>
                            <button id="fitBlack" class="fit-btn px-3 py-1.5 text-xs rounded-lg transition-all bg-gray-800 text-gray-400 hover:bg-gray-700 hover:text-gray-200">
                                Black Bars
                            </button>
                            <button id="fitCrop" class="fit-btn px-3 py-1.5 text-xs rounded-lg transition-all bg-gray-800 text-gray-400 hover:bg-gray-700 hover:text-gray-200">
                                Crop
                            </button>
                        </div>

                        <div class="h-8 w-px bg-gray-700 hidden md:block"></div>

                        <button id="enhanceBtn" class="px-3 py-1.5 text-xs rounded-lg transition-all whitespace-nowrap flex items-center gap-2 bg-gray-800 text-gray-400 hover:bg-gray-700 hover:text-gray-200">
                            <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path></svg>
                            NatGeo
                        </button>

                        <div class="h-8 w-px bg-gray-700 hidden md:block"></div>

                        <button id="removeWatermarkBtn" class="px-3 py-1.5 text-xs rounded-lg transition-all whitespace-nowrap flex items-center gap-2 bg-gradient-to-r from-red-600 to-rose-600 text-white shadow-lg shadow-red-900/50">
                            <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                            Remove Watermarks
                        </button>
                    </div>

                    <button id="downloadCurrentBtn" class="w-full xl:w-auto px-6 py-2 bg-white text-gray-900 rounded-lg font-semibold hover:bg-gray-200 transition-colors text-sm flex items-center justify-center gap-2 whitespace-nowrap">
                        Download Current
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg>
                    </button>
                </div>

                <div id="watermarkControls" class="hidden mt-4 z-10 w-full max-w-4xl bg-gray-900/ backdrop-blur p-4 rounded-xl border border-red-800 shadow-2xl">
                    <div class="flex flex-col md:flex-row items-center gap-4">
                        <div class="flex items-center gap-2">
                            <label class="text-xs text-gray-400">Sensitivity:</label>
                            <input type="range" id="sensitivitySlider" min="1" max="10" value="5" class="w-24">
                            <span id="sensitivityValue" class="text-xs text-gray-300">5</span>
                        </div>
                        <button id="detectWatermarksBtn" class="px-3 py-1.5 text-xs rounded-lg bg-red-600 hover:bg-red-500 text-white transition-colors">
                            Detect & Remove All
                        </button>
                        <button id="manualSelectBtn" class="px-3 py-1.5 text-xs rounded-lg bg-gray-800 hover:bg-gray-700 text-gray-200 transition-colors">
                            Manual Select
                        </button>
                        <button id="clearRegionsBtn" class="px-3 py-1.5 text-xs rounded-lg bg-gray-800 hover:bg-gray-700 text-gray-200 transition-colors">
                            Clear Regions
                        </button>
                        <div class="text-xs text-gray-500">
                            Detected: <span id="detectedCount">0</span> regions
                        </div>
                    </div>
                </div>
            </main>

            <div class="hidden lg:flex w-80 border-l border-gray-800 bg-gray-900 z-20 shadow-2xl shrink-0 flex-col">
                <div class="p-6 border-b border-gray-800">
                    <h2 class="text-xl font-bold text-white mb-1 flex items-center gap-2">
                        <span class="bg-gradient-to-r from-blue-400 to-purple-500 bg-clip-text text-transparent">Smart</span>
                        <span>Metadata</span>
                    </h2>
                    <p class="text-sm text-gray-400">Generate titles, descriptions & hashtags</p>
                </div>
                
                <div id="metadataPanel" class="flex-1 overflow-y-auto p-6">
                    <div id="metadataPlaceholder" class="h-full flex flex-col items-center justify-center text-gray-500 text-center">
                        <svg class="w-12 h-12 mb-4 opacity-30" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path></svg>
                        <p>Process an image to generate metadata.</p>
                    </div>
                    
                    <div id="metadataContent" class="hidden space-y-6 animate-fade-in">
                        <button id="generateMetadataBtn" class="w-full py-3 px-4 bg-gradient-to-r from-indigo-600 to-purple-600 hover:from-indigo-500 hover:to-purple-500 text-white font-medium rounded-lg shadow-lg transform transition hover:scale-[1.02] active:scale-[0.98] flex items-center justify-center gap-2">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19.428 15.428a2 2 0 00-1.022-.547l-2.387-.477a6 6 0 00-3.86.517l-.318.158a6 6 0 01-3.86.517L6.05 15.21a2 2 0 00-1.806.547M8 4h8l-1 1v5.172a2 2 0 00.586 1.414l5 5c1.26 1.26.367 3.414-1.415 3.414H4.828c-1.782 0-2.674-2.154-1.414-3.414l5-5A2 2 0 009 10.172V5L8 4z"></path></svg>
                            Generate Metadata
                        </button>
                        
                        <div id="metadataResults" class="hidden space-y-6">
                            <div class="bg-gray-800/50 rounded-xl p-4 border border-gray-700">
                                <label class="block text-xs uppercase tracking-wider text-gray-400 mb-2 font-semibold"> Title</label>
                                <div id="generatedTitle" class="text-white font-medium text-lg leading-snug select cursor-text"></div>
                                <button class="copy-btn mt-3 text-xs text-indigo-400 hover:text-indigo-300 flex items-center gap-1" data-target="generatedTitle">
                                    <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>
                                    Copy
                                </button>
                            </div>

                            <div class="bg-gray-800/50 rounded-xl p-4 border border-gray-700">
                                <label class="block text-xs uppercase tracking-wider text-gray-400 mb-2 font-semibold">Description</label>
                                <div id="generatedDescription" class="text-gray-200 text-sm leading-relaxed whitespace-pre-wrap select-all cursor-text"></div>
                                <button class="copy-btn mt-3 text-xs text-indigo-400 hover:text-indigo-300 flex items-center gap-1" data-target="generatedDescription">
                                    <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>
                                    Copy
                                </button>
                            </div>

                            <div class="bg-gray-800/50 rounded-xl p-4 border border-gray-700">
                                <label class="block text-xs uppercase tracking-wider text-gray-400 mb-2 font-semibold">Hashtags</label>
                                <div id="generatedHashtags" class="flex flex-wrap gap-2"></div>
                                <button id="copyHashtagsBtn" class="mt-3 text-xs text-indigo-400 hover:text-indigo-300 flex items-center gap-1">
                                    <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>
                                    Copy All
                                </button>
                            </div>

                            <button id="regenerateBtn" class="w-full py-2 text-xs text-gray-500 hover:text-white transition-colors">
                                Regenerate
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============ STATE ============
        const MAX_BATCH_SIZE = 200;
        const MAX_FILE_SIZE = 50 * 1024 * 1024; // 50MB limit
        
        const PRESETS = {
            ULTRA_8K: { width: 7680, height: 4320, label: '8K Ultra' },
            YT_THUMBNAIL: { width: 1280, height: 720, label: 'YT Thumbnail' }
        };
        
        const FIT_MODES = {
            CONTAIN_BLUR: 'CONTAIN_BLUR',
            CONTAIN_BLACK: 'CONTAIN_BLACK',
            COVER: 'COVER'
        };
        
        let state = {
            batchItems: [],
            selectedId: null,
            sourceImage: null,
            processedDataUrl: null,
            fitMode: FIT_MODES.CONTAIN_BLUR,
            outputPreset: 'ULTRA_8K',
            enhanceQuality: false,
            batchEnhance: false,
            isProcessing: false,
            isZipping: false,
            currentHashtags: [],
            processingCache: new Map(), // Cache for processed images
            // Watermark removal state
            watermarkRemovalEnabled: false,
            watermarkRegions: [],
            detectionSensitivity: 5,
            manualSelectionMode: false,
            isSelecting: false,
            selectionStart: null,
            selectionEnd: null
        };

        // ============ DOM ELEMENTS ============
        const elements = {
            fileInput: document.getElementById('fileInput'),
            addImagesBtn: document.getElementById('addImagesBtn'),
            downloadAllBtn: document.getElementById('downloadAllBtn'),
            batchList: document.getElementById('batchList'),
            emptyState: document.getElementById('emptyState'),
            queueCount: document.getElementById('queueCount'),
            imageCount: document.getElementById('imageCount'),
            previewContainer: document.getElementById('previewContainer'),
            previewPlaceholder: document.getElementById('previewPlaceholder'),
            previewImage: document.getElementById('previewImage'),
            watermarkCanvas: document.getElementById('watermarkCanvas'),
            processingOverlay: document.getElementById('processingOverlay'),
            processingText: document.getElementById('processingText'),
            dimensionBadge: document.getElementById('dimensionBadge'),
            enhanceBadge: document.getElementById('enhanceBadge'),
            watermarkBadge: document.getElementById('watermarkBadge'),
            controlsPanel: document.getElementById('controlsPanel'),
            dropZone: document.getElementById('dropZone'),
            preset8k: document.getElementById('preset8k'),
            presetYT: document.getElementById('presetYT'),
            fitBlur: document.getElementById('fitBlur'),
            fitBlack: document.getElementById('fitBlack'),
            fitCrop: document.getElementById('fitCrop'),
            enhanceBtn: document.getElementById('enhanceBtn'),
            downloadCurrentBtn: document.getElementById('downloadCurrentBtn'),
            batchEnhanceToggle: document.getElementById('batchEnhanceToggle'),
            batchEnhanceKnob: document.getElementById('batchEnhanceKnob'),
            batchEnhanceLabel: document.getElementById('batchEnhanceLabel'),
            // Watermark elements
            watermarkToggle: document.getElementById('watermarkToggle'),
            watermarkKnob: document.getElementById('watermarkKnob'),
            watermarkLabel: document.getElementById('watermarkLabel'),
            watermarkControls: document.getElementById('watermarkControls'),
            sensitivitySlider: document.getElementById('sensitivitySlider'),
            sensitivityValue: document.getElementById('sensitivityValue'),
            detectWatermarksBtn: document.getElementById('detectWatermarksBtn'),
            manualSelectBtn: document.getElementById('manualSelectBtn'),
            clearRegionsBtn: document.getElementById('clearRegionsBtn'),
            detectedCount: document.getElementById('detectedCount'),
            removeWatermarkBtn: document.getElementById('removeWatermarkBtn'),
            // Metadata
            metadataPlaceholder: document.getElementById('metadataPlaceholder'),
            metadataContent: document.getElementById('metadataContent'),
            metadataResults: document.getElementById('metadataResults'),
            generateMetadataBtn: document.getElementById('generateMetadataBtn'),
            generatedTitle: document.getElementById('generatedTitle'),
            generatedDescription: document.getElementById('generatedDescription'),
            generatedHashtags: document.getElementById('generatedHashtags'),
            copyHashtagsBtn: document.getElementById('copyHashtagsBtn'),
            regenerateBtn: document.getElementById('regenerateBtn')
        };

        // ============ NOTIFICATION SYSTEM ============
        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `toast fixed top-4 right-4 z-50 px-4 py-2 rounded-lg text-sm font-medium text-white ${
                type === 'error' ? 'bg-red-600' : 
                type === 'success' ? 'bg-green-600' : 'bg-indigo-600'
            }`;
            toast.textContent = message;
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.style.opacity = '0';
                setTimeout(() => document.body.removeChild(toast), 300);
            }, 3000);
        }

        // ============ IMAGE PROCESSING ============
        function loadImage(source) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = "anonymous";
                img.onload = () => resolve(img);
                img.onerror = () => reject(new Error('Failed to load image'));
                img.src = source;
            });
        }

        // Unified canvas drawing logic
        function drawToCanvas(ctx, source, fitMode, preset, enhance, watermarkRegions = []) {
            const { width: targetW, height: targetH } = PRESETS[preset];
            const srcW = source.width;
            const srcH = source.height;
            const targetRatio = targetW / targetH;
            const srcRatio = srcW / srcH;
            
            let drawW = targetW;
            let drawH = targetH;
            let offsetX = 0;
            let offsetY = 0;
            
            if (fitMode === FIT_MODES.COVER) {
                if (srcRatio > targetRatio) {
                    drawH = targetH;
                    drawW = srcW * (targetH / srcH);
                    offsetX = (targetW - drawW) / 2;
                } else {
                    drawW = targetW;
                    drawH = srcH * (targetW / srcW);
                    offsetY = (targetH - drawH) / 2;
                }
            } else if (fitMode === FIT_MODES.CONTAIN_BLACK || fitMode === FIT_MODES.CONTAIN_BLUR) {
                if (srcRatio > targetRatio) {
                    drawW = targetW;
                    drawH = srcH * (targetW / srcW);
                    offsetY = (targetH - drawH) / 2;
                } else {
                    drawH = targetH;
                    drawW = srcW * (targetH / srcH);
                    offsetX = (targetW - drawW) / 2;
                }
                
                if (fitMode === FIT_MODES.CONTAIN_BLUR) {
                    ctx.save();
                    const blurRadius = preset === 'ULTRA_8K' ? 80 : 15;
                    ctx.filter = `blur(${blurRadius}px) brightness(0.7)`;
                    
                    const bgScale = Math.max(targetW / srcW, targetH / srcH);
                    const bgW = srcW * bgScale;
                    const bgH = srcH * bgScale;
                    const bgX = (targetW - bgW) / 2;
                    const bgY = (targetH - bgH) / 2;
                    ctx.drawImage(source, bgX, bgY, bgW, bgH);
                    ctx.restore();
                }
            }
            
            if (enhance) {
                ctx.filter = 'contrast(1.08) saturate(1.12) brightness(1.02)';
            }
            
            ctx.drawImage(source, offsetX, offsetY, drawW, drawH);
            ctx.filter = 'none';
            
            // Apply watermark removal
            if (watermarkRegions.length > 0) {
                watermarkRegions.forEach(region => {
                    const x = Math.max(0, Math.min(targetW, region.x * targetW));
                    const y = Math.max(0, Math.min(targetH, region.y * targetH));
                    const w = Math.max(1, Math.min(targetW - x, region.w * targetW));
                    const h = Math.max(1, Math.min(targetH - y, region.h * targetH));
                    
                    // Fixed Inpainting Logic
                    ctx.save();
                    ctx.beginPath();
                    ctx.rect(x, y, w, h);
                    ctx.clip();
                    
                    // Heavy blur for the watermark area
                    ctx.filter = 'blur(30px)'; 
                    
                    // Redraw the image portion into the clipped area
                    // This ensures we blur the existing content
                    ctx.drawImage(source, offsetX, offsetY, drawW, drawH);
                    
                    ctx.restore();
                });
            }
            
            if (enhance) {
                const gradient = ctx.createRadialGradient(
                    targetW / 2, targetH / 2, targetW * 0.45,
                    targetW / 2, targetH / 2, targetW * 0.9
                );
                gradient.addColorStop(0, 'rgba(0,0,0,0)');
                gradient.addColorStop(1, 'rgba(0,0,0,0.25)');
                
                ctx.fillStyle = gradient;
                ctx.globalCompositeOperation = 'multiply';
                ctx.fillRect(0, 0, targetW, targetH);
                ctx.globalCompositeOperation = 'source-over';
            }
            
            return { drawW, drawH, offsetX, offsetY };
        }

        function processImage(source, fitMode, preset, enhance, watermarkRegions = []) {
            const cacheKey = `${fitMode}-${preset}-${enhance}-${source.width}-${source.height}-${watermarkRegions.length}`;
            if (state.processingCache.has(cacheKey)) {
                return state.processingCache.get(cacheKey);
            }
            
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d', { alpha: false });
            
            const { width: targetW, height: targetH } = PRESETS[preset];
            canvas.width = targetW;
            canvas.height = targetH;
            
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, targetW, targetH);
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            
            drawToCanvas(ctx, source, fitMode, preset, enhance, watermarkRegions);
            
            const dataUrl = canvas.toDataURL('image/jpeg', 0.95);
            state.processingCache.set(cacheKey, dataUrl);
            
            if (state.processingCache.size > 50) {
                const firstKey = state.processingCache.keys().next().value;
                state.processingCache.delete(firstKey);
            }
            
            return dataUrl;
        }

        function processImageToBlob(source, fitMode, preset, enhance, watermarkRegions = []) {
            return new Promise((resolve, reject) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d', { alpha: false });
                
                const { width: targetW, height: targetH } = PRESETS[preset];
                canvas.width = targetW;
                canvas.height = targetH;
                
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, targetW, targetH);
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                
                drawToCanvas(ctx, source, fitMode, preset, enhance, watermarkRegions);
                
                canvas.toBlob((blob) => {
                    if (blob) resolve(blob);
                    else reject(new Error("Canvas to Blob failed"));
                }, 'image/jpeg', 0.95);
            });
        }

        // ============ WATERMARK DETECTION & REMOVAL ============
        
        // Detect potential watermark regions using heuristic analysis
        function detectWatermarks(img, sensitivity = 5) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;
            
            const regions = [];
            const threshold = sensitivity * 10;
            
            // Check common watermark positions: corners and bottom center
            const checkAreas = [
                { x: 0, y: 0, w: width * 0.3, h: height * 0.2 }, // Top-left
                { x: width * 0.7, y: 0, w: width * 0.3, h: height * 0.2 }, // Top-right
                { x: width * 0.3, y: height * 0.85, w: width * 0.4, h: height * 0.15 }, // Bottom center
                { x: 0, y: height * 0.8, w: width * 0.25, h: height * 0.2 }, // Bottom-left
                { x: width * 0.75, y: height * 0.8, w: width * 0.25, h: height * 0.2 } // Bottom-right
            ];
            
            checkAreas.forEach(area => {
                let highContrastPixels = 0;
                let totalPixels = 0;
                
                for (let y = area.y; y < area.y + area.h && y < height; y += 4) {
                    for (let x = area.x; x < area.x + area.w && x < width; x += 4) {
                        const idx = (y * width + x) * 4;
                        const r = data[idx];
                        const g = data[idx + 1];
                        const b = data[idx + 2];
                        
                        // Check for high contrast (text-like)
                        const gray = 0.299 * r + 0.587 * g + 0.114 * b;
                        if (gray < 50 || gray > 200) highContrastPixels++;
                        totalPixels++;
                    }
                }
                
                const contrastRatio = highContrastPixels / totalPixels;
                if (contrastRatio > 0.1) {
                    regions.push({
                        x: area.x / width,
                        y: area.y / height,
                        w: area.w / width,
                        h: area.h / height,
                        confidence: contrastRatio
                    });
                }
            });
            
            return regions;
        }

        // Manual selection handlers
        function setupManualSelection() {
            if (!state.manualSelectionMode) return;
            
            const canvas = elements.watermarkCanvas;
            canvas.style.pointerEvents = 'auto';
            
            let isSelecting = false;
            let startX, startY;
            
            canvas.addEventListener('mousedown', (e) => {
                isSelecting = true;
                const rect = canvas.getBoundingClientRect();
                startX = e.clientX - rect.left;
                startY = e.clientY - rect.top;
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (!isSelecting) return;
                const rect = canvas.getBoundingClientRect();
                const currentX = e.clientX - rect.left;
                const currentY = e.clientY - rect.top;
                
                // Draw selection rectangle
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.strokeStyle = '#fbbf24';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.strokeRect(startX, startY, currentX - startX, currentY - startY);
            });
            
            canvas.addEventListener('mouseup', (e) => {
                if (!isSelecting) return;
                isSelecting = false;
                
                const rect = canvas.getBoundingClientRect();
                const endX = e.clientX - rect.left;
                const endY = e.clientY - rect.top;
                
                // Add region
                const region = {
                    x: Math.min(startX, endX) / canvas.width,
                    y: Math.min(startY, endY) / canvas.height,
                    w: Math.abs(endX - startX) / canvas.width,
                    h: Math.abs(endY - startY) / canvas.height,
                    manual: true
                };
                
                state.watermarkRegions.push(region);
                renderWatermarkRegions();
                updateUI();
            });
        }

        function renderWatermarkRegions() {
            // Clear existing overlays
            document.querySelectorAll('.watermark-overlay').forEach(el => el.remove());
            
            // Draw regions
            state.watermarkRegions.forEach((region, index) => {
                const overlay = document.createElement('div');
                overlay.className = 'watermark-overlay';
                overlay.style.left = `${region.x * 100}%`;
                overlay.style.top = `${region.y * 100}%`;
                overlay.style.width = `${region.w * 100}%`;
                overlay.style.height = `${region.h * 100}%`;
                overlay.dataset.index = index;
                
                const removeBtn = document.createElement('button');
                removeBtn.innerHTML = 'Ã—';
                removeBtn.className = 'absolute -top-2 -right-2 w-4 h-4 bg-red-500 text-white text-xs rounded-full';
                removeBtn.onclick = () => {
                    state.watermarkRegions.splice(index, 1);
                    renderWatermarkRegions();
                    updateUI();
                };
                
                overlay.appendChild(removeBtn);
                elements.previewContainer.appendChild(overlay);
            });
            
            elements.detectedCount.textContent = state.watermarkRegions.length;
        }

        async function autoRemoveWatermarks() {
            if (!state.selectedId || !state.sourceImage) return;
            
            elements.processingOverlay.classList.remove('hidden');
            elements.processingText.textContent = 'Detecting watermarks...';
            
            try {
                // Detect watermarks
                const regions = detectWatermarks(state.sourceImage, state.detectionSensitivity);
                state.watermarkRegions = [...regions];
                
                renderWatermarkRegions();
                updateUI();
                
                if (regions.length > 0) {
                    showToast(`Detected ${regions.length} potential watermark regions`, 'info');
                    
                    // Reprocess with watermark removal
                    elements.processingText.textContent = 'Removing watermarks...';
                    await updatePreview();
                    
                    showToast('Watermarks removed successfully', 'success');
                    elements.watermarkBadge.classList.remove('hidden');
                } else {
                    showToast('No watermarks detected', 'info');
                    elements.watermarkBadge.classList.add('hidden');
                }
            } catch (error) {
                console.error('Watermark removal failed:', error);
                showToast('Failed to process image', 'error');
            }
            
            elements.processingOverlay.classList.add('hidden');
        }

        // ============ METADATA GENERATION (Local - No API) ============
        const TITLE_TEMPLATES = [
            "ðŸ”¥ {adjective} {subject} You Won't Believe!",
            "ðŸ˜± The Most {adjective} {subject} Ever Captured",
            "âœ¨ Stunning {subject} - {adjective} Moments",
            "ðŸŒŸ {adjective} {subject} That Will Blow Your Mind",
            "ðŸ“¸ Incredible {subject} - Must See {adjective} Shots",
            "ðŸŽ¬ {adjective} {subject} Compilation - Best of 2024",
            "ðŸ’« Breathtaking {subject} - {adjective} Photography",
            "ðŸ† Top {adjective} {subject} Moments Caught on Camera"
        ];
        
        const ADJECTIVES = [
            "Amazing", "Stunning", "Incredible", "Breathtaking", "Epic",
            "Mesmerizing", "Spectacular", "Magnificent", "Extraordinary", "Phenomenal",
            "Captivating", "Awe-Inspiring", "Remarkable", "Sensational", "Majestic"
        ];
        
        const SUBJECTS = [
            "Nature", "Wildlife", "Landscapes", "Moments", "Views",
            "Scenery", "Photography", "Captures", "Shots", "Visuals",
            "Images", "Pictures", "Frames", "Compositions", "Art"
        ];
        
        const DESCRIPTION_TEMPLATES = [
            "Discover the beauty of this {adjective} capture that showcases the incredible world around us. This stunning visual will leave you speechless.\n\nDon't forget to like, subscribe, and hit the bell for more amazing content!",
            "Experience the magic of this {adjective} moment frozen in time. Every detail tells a story of nature's incredible artistry.\n\nðŸ‘‰ Subscribe for daily inspiration and stunning visuals!",
            "Witness the extraordinary beauty captured in this {adjective} image. From composition to colors, every element is perfectly balanced.\n\nðŸ”” Turn on notifications to never miss our latest uploads!"
        ];
        
        const HASHTAG_POOLS = [
            ["photography", "photooftheday", "picoftheday", "instagood", "beautiful"],
            ["nature", "naturephotography", "landscape", "wildlife", "earthpix"],
            ["travel", "wanderlust", "adventure", "explore", "travelgram"],
            ["art", "artistic", "creative", "visualart", "composition"],
            ["stunning", "amazing", "incredible", "breathtaking", "epic"],
            ["viral", "trending", "fyp", "foryou", "discover"],
            ["youtube", "youtuber", "subscribe", "video", "content"],
            ["4k", "8k", "hdr", "highquality", "professional"]
        ];

        let metadataCache = new Map();

        function generateMetadata() {
            const adjective = ADJECTIVES[Math.floor(Math.random() * ADJECTIVES.length)];
            const subject = SUBJECTS[Math.floor(Math.random() * SUBJECTS.length)];
            
            const titleTemplate = TITLE_TEMPLATES[Math.floor(Math.random() * TITLE_TEMPLATES.length)];
            const title = titleTemplate.replace('{adjective}', adjective).replace('{subject}', subject);
            
            const descTemplate = DESCRIPTION_TEMPLATES[Math.floor(Math.random() * DESCRIPTION_TEMPLATES.length)];
            const description = descTemplate.replace('{adjective}', adjective.toLowerCase());
            
            const hashtags = [];
            HASHTAG_POOLS.forEach(pool => {
                const shuffled = [...pool].sort(() => Math.random() - 0.5);
                hashtags.push(...shuffled.slice(0, 2));
            });
            
            const finalHashtags = hashtags.sort(() => Math.random() - 0.5).slice(0, 15);
            
            const metadata = { title, description, hashtags: finalHashtags };
            
            const cacheKey = `${adjective}-${subject}`;
            metadataCache.set(cacheKey, metadata);
            if (metadataCache.size > 50) {
                const firstKey = metadataCache.keys().next().value;
                metadataCache.delete(firstKey);
            }
            
            return metadata;
        }

        // ============ UI UPDATES ============
        function updateUI() {
            elements.queueCount.textContent = `${state.batchItems.length}/${MAX_BATCH_SIZE}`;
            elements.imageCount.textContent = `${state.batchItems.length} / ${MAX_BATCH_SIZE} images`;
            
            if (state.batchItems.length >= MAX_BATCH_SIZE) {
                elements.imageCount.className = 'text-xs mr-2 hidden sm:block text-amber-400 font-semibold';
            } else {
                elements.imageCount.className = 'text-xs mr-2 hidden sm:block text-gray-400';
            }
            
            if (state.batchItems.length > 0) {
                elements.downloadAllBtn.classList.remove('hidden');
                elements.downloadAllBtn.classList.add('flex');
            } else {
                elements.downloadAllBtn.classList.add('hidden');
                elements.downloadAllBtn.classList.remove('flex');
            }
            
            renderBatchList();
            updatePreview();
            
            if (state.selectedId) {
                elements.controlsPanel.classList.remove('hidden');
                elements.metadataPlaceholder.classList.add('hidden');
                elements.metadataContent.classList.remove('hidden');
            } else {
                elements.controlsPanel.classList.add('hidden');
                elements.metadataPlaceholder.classList.remove('hidden');
                elements.metadataContent.classList.add('hidden');
            }
            
            // Update preset buttons
            if (state.outputPreset === 'ULTRA_8K') {
                elements.preset8k.className = 'px-3 py-1.5 text-xs font-medium rounded-md transition-all bg-gray-700 text-white shadow-sm';
                elements.presetYT.className = 'px-3 py-1.5 text-xs font-medium rounded-md transition-all text-gray-400 hover:text-gray-200';
            } else {
                elements.presetYT.className = 'px-3 py-1.5 text-xs font-medium rounded-md transition-all bg-red-600/90 text-white shadow-sm';
                elements.preset8k.className = 'px-3 py-1.5 text-xs font-medium rounded-md transition-all text-gray-400 hover:text-gray-200';
            }
            
            // Update fit mode buttons
            document.querySelectorAll('.fit-btn').forEach(btn => {
                btn.className = 'fit-btn px-3 py-1.5 text-xs rounded-lg transition-all bg-gray-800 text-gray-400 hover:bg-gray-700 hover:text-gray-200';
            });
            
            if (state.fitMode === FIT_MODES.CONTAIN_BLUR) {
                elements.fitBlur.className = 'fit-btn px-3 py-1.5 text-xs rounded-lg transition-all bg-indigo-600 text-white shadow-lg shadow-indigo-900/50';
            } else if (state.fitMode === FIT_MODES.CONTAIN_BLACK) {
                elements.fitBlack.className = 'fit-btn px-3 py-1.5 text-xs rounded-lg transition-all bg-indigo-600 text-white shadow-lg shadow-indigo-900/50';
            } else if (state.fitMode === FIT_MODES.COVER) {
                elements.fitCrop.className = 'fit-btn px-3 py-1.5 text-xs rounded-lg transition-all bg-indigo-600 text-white shadow-lg shadow-indigo-900/50';
            }
            
            // Update enhance button
            if (state.enhanceQuality) {
                elements.enhanceBtn.className = 'px-3 py-1.5 text-xs rounded-lg transition-all whitespace-nowrap flex items-center gap-2 bg-gradient-to-r from-amber-600 to-orange-600 text-white shadow-lg shadow-orange-900/50 ring-1 ring-orange-400/50';
            } else {
                elements.enhanceBtn.className = 'px-3 py-1.5 text-xs rounded-lg transition-all whitespace-nowrap flex items-center gap-2 bg-gray-800 text-gray-400 hover:bg-gray-700 hover:text-gray-200';
            }
            
            // Update batch enhance toggle
            if (state.batchEnhance) {
                elements.batchEnhanceToggle.className = 'w-8 h-4 rounded-full p-0.5 transition-colors bg-indigo-500 cursor-pointer';
                elements.batchEnhanceKnob.className = 'w-3 h-3 bg-white rounded-full shadow-md transform transition-transform translate-x-4';
                elements.batchEnhanceLabel.className = 'text-xs font-medium text-indigo-400';
            } else {
                elements.batchEnhanceToggle.className = 'w-8 h-4 rounded-full p-0.5 transition-colors bg-gray-700 cursor-pointer';
                elements.batchEnhanceKnob.className = 'w-3 h-3 bg-white rounded-full shadow-md transform transition-transform translate-x-0';
                elements.batchEnhanceLabel.className = 'text-xs font-medium text-gray-500 group-hover:text-gray-400';
            }
            
            // Update watermark removal toggle
            if (state.watermarkRemovalEnabled) {
                elements.watermarkToggle.className = 'w-10 h-4 rounded-full p-0.5 transition-colors bg-red-500 cursor-pointer';
                elements.watermarkKnob.className = 'w-3 h-3 bg-white rounded-full shadow-md transform transition-transform translate-x-6';
                elements.watermarkLabel.className = 'text-xs font-medium text-red-400 hidden md:block';
                elements.watermarkControls.classList.remove('hidden');
                elements.watermarkBadge.classList.remove('hidden');
            } else {
                elements.watermarkToggle.className = 'w-10 h-4 rounded-full p-0.5 transition-colors bg-gray-700 cursor-pointer';
                elements.watermarkKnob.className = 'w-3 h-3 bg-white rounded-full shadow-md transform transition-transform translate-x-0';
                elements.watermarkLabel.className = 'text-xs font-medium text-gray-500 group-hover:text-gray-400 hidden md:block';
                elements.watermarkControls.classList.add('hidden');
                elements.watermarkBadge.classList.add('hidden');
            }
            
            // Update manual selection mode
            if (state.manualSelectionMode) {
                elements.manualSelectBtn.className = 'px-3 py-1.5 text-xs rounded-lg bg-red-600 hover:bg-red-500 text-white transition-colors';
                elements.watermarkCanvas.classList.remove('hidden');
                if (state.selectedId) setupManualSelection();
            } else {
                elements.manualSelectBtn.className = 'px-3 py-1.5 text-xs rounded-lg bg-gray-800 hover:bg-gray-700 text-gray-200 transition-colors';
                elements.watermarkCanvas.classList.add('hidden');
            }
            
            const { width, height } = PRESETS[state.outputPreset];
            elements.dimensionBadge.textContent = `${width} x ${height}`;
        }

        function renderBatchList() {
            if (state.batchItems.length === 0) {
                elements.batchList.innerHTML = '<div class="text-center py-10 text-gray-600 text-sm p-2">No images. Add some to start.</div>';
                return;
            }
            
            elements.batchList.innerHTML = state.batchItems.map((item, idx) => `
                <div class="batch-item group relative flex items-center gap-3 p-2 rounded-lg cursor-pointer transition-all ${
                    state.selectedId === item.id 
                    ? 'bg-indigo-900/30 border border-indigo-500/30 ring-1 ring-indigo-500/20' 
                    : 'hover:bg-gray-800 border border-transparent'
                }" data-id="${item.id}">
                    <div class="w-16 h-9 bg-gray-950 rounded overflow-hidden shrink-0 relative">
                        <img src="${item.previewUrl}" alt="thumb" class="w-full h-full object-cover" loading="lazy" />
                        <div class="absolute top-0 right-0 bg-black/50 text-[8px] text-white px-1">${idx + 1}</div>
                    </div>
                    <div class="flex-1 min-w-0 hidden md:block">
                        <p class="text-sm text-gray-200 truncate">${item.file.name}</p>
                        <p class="text-[10px] text-gray-500">${(item.file.size / 1024 / 1024).toFixed(2)} MB</p>
                    </div>
                    <button class="remove-btn absolute top-1 right-1 p-1 bg-red-500/80 text-white rounded-full opacity-0 group-hover:opacity-100 transition-opacity hover:bg-red-600" data-id="${item.id}" title="Remove">
                        <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </button>
                </div>
            `).join('');
            
            document.querySelectorAll('.batch-item').forEach(el => {
                el.addEventListener('click', (e) => {
                    if (!e.target.closest('.remove-btn')) {
                        selectItem(el.dataset.id);
                    }
                });
            });
            
            document.querySelectorAll('.remove-btn').forEach(el => {
                el.addEventListener('click', (e) => {
                    e.stopPropagation();
                    removeItem(el.dataset.id);
                });
            });
        }

        async function updatePreview() {
            if (!state.selectedId || !state.sourceImage) {
                elements.previewPlaceholder.classList.remove('hidden');
                elements.previewImage.classList.add('hidden');
                elements.dimensionBadge.classList.add('hidden');
                elements.enhanceBadge.classList.add('hidden');
                elements.watermarkBadge.classList.add('hidden');
                return;
            }
            
            elements.previewPlaceholder.classList.add('hidden');
            elements.previewImage.classList.remove('hidden');
            elements.dimensionBadge.classList.remove('hidden');
            
            if (state.enhanceQuality) {
                elements.enhanceBadge.classList.remove('hidden');
            } else {
                elements.enhanceBadge.classList.add('hidden');
            }
            
            if (state.watermarkRegions.length > 0) {
                elements.watermarkBadge.classList.remove('hidden');
            } else {
                elements.watermarkBadge.classList.add('hidden');
            }
            
            elements.processingOverlay.classList.remove('hidden');
            elements.processingText.textContent = 'Processing...';
            
            try {
                const dataUrl = processImage(state.sourceImage, state.fitMode, state.outputPreset, state.enhanceQuality, state.watermarkRegions);
                state.processedDataUrl = dataUrl;
                elements.previewImage.src = dataUrl;
            } catch (e) {
                console.error('Processing failed:', e);
                showToast('Image processing failed', 'error');
            }
            
            elements.processingOverlay.classList.add('hidden');
        }

        // ============ ACTIONS ============
        function validateFile(file) {
            if (!file.type.startsWith('image/')) {
                showToast(`${file.name} is not an image`, 'error');
                return false;
            }
            if (file.size > MAX_FILE_SIZE) {
                showToast(`${file.name} exceeds 50MB limit`, 'error');
                return false;
            }
            return true;
        }

        async function addFiles(files) {
            const filesArray = Array.from(files).filter(validateFile);
            const remainingSlots = MAX_BATCH_SIZE - state.batchItems.length;
            
            if (remainingSlots <= 0) {
                showToast(`Maximum ${MAX_BATCH_SIZE} images allowed`, 'error');
                return;
            }
            
            if (filesArray.length > remainingSlots) {
                showToast(`Only ${remainingSlots} slots available`, 'warning');
            }
            
            const itemsToAdd = filesArray.slice(0, remainingSlots);
            
            const newItems = itemsToAdd.map(file => ({
                id: crypto.randomUUID(),
                file,
                previewUrl: URL.createObjectURL(file),
                processedUrl: null,
                status: 'pending'
            }));
            
            state.batchItems = [...state.batchItems, ...newItems];
            
            if (!state.selectedId && newItems.length > 0) {
                await selectItem(newItems[0].id);
            } else {
                updateUI();
            }
            
            showToast(`Added ${newItems.length} image${newItems.length > 1 ? 's' : ''}`, 'success');
        }

        async function selectItem(id) {
            state.selectedId = id;
            const item = state.batchItems.find(i => i.id === id);
            
            if (item) {
                try {
                    state.sourceImage = await loadImage(item.previewUrl);
                } catch (e) {
                    console.error('Failed to load image:', e);
                    showToast('Failed to load image', 'error');
                    state.sourceImage = null;
                }
            }
            
            // Clear caches when switching images
            state.processingCache.clear();
            metadataCache.clear();
            state.watermarkRegions = [];
            state.manualSelectionMode = false;
            
            elements.metadataResults.classList.add('hidden');
            elements.generateMetadataBtn.classList.remove('hidden');
            elements.watermarkCanvas.classList.add('hidden');
            
            renderWatermarkRegions();
            updateUI();
            await updatePreview();
        }

        function removeItem(id) {
            const item = state.batchItems.find(i => i.id === id);
            if (item) {
                URL.revokeObjectURL(item.previewUrl);
            }
            
            state.batchItems = state.batchItems.filter(item => item.id !== id);
            
            if (id === state.selectedId) {
                if (state.batchItems.length > 0) {
                    selectItem(state.batchItems[0].id);
                } else {
                    state.selectedId = null;
                    state.sourceImage = null;
                    state.processedDataUrl = null;
                    state.processingCache.clear();
                    metadataCache.clear();
                    state.watermarkRegions = [];
                }
            }
            
            updateUI();
            showToast('Image removed', 'info');
        }

        function downloadCurrent() {
            if (!state.processedDataUrl || !state.selectedId) return;
            
            const item = state.batchItems.find(i => i.id === state.selectedId);
            if (!item) return;
            
            const link = document.createElement('a');
            link.href = state.processedDataUrl;
            
            let suffix = '';
            if (state.enhanceQuality) suffix += '-natgeo';
            if (state.watermarkRegions.length > 0) suffix += '-clean';
            if (state.outputPreset === 'ULTRA_8K') suffix += '-8k.jpg';
            else suffix += '-thumbnail.jpg';
            
            const name = item.file.name.replace(/\.[^/.]+$/, "");
            link.download = `${name}${suffix}`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            showToast('Download started', 'success');
        }

        async function downloadAll() {
            if (state.batchItems.length === 0 || state.isZipping) return;
            
            state.isZipping = true;
            const btn = elements.downloadAllBtn;
            const originalContent = btn.innerHTML;
            
            const zip = new JSZip();
            const folderName = state.outputPreset === 'ULTRA_8K' ? "framecraft-8k" : "framecraft-thumbnails";
            const folder = zip.folder(folderName);
            
            let successCount = 0;
            let failCount = 0;
            
            try {
                for (let i = 0; i < state.batchItems.length; i++) {
                    const item = state.batchItems[i];
                    const progress = Math.round(((i + 1) / state.batchItems.length) * 100);
                    
                    btn.innerHTML = `
                        <div class="spinner w-4 h-4 border-2"></div>
                        <span class="hidden sm:inline">Processing ${i + 1}/${state.batchItems.length}</span>
                        <span class="sm:hidden">${progress}%</span>
                    `;
                    
                    await new Promise(resolve => setTimeout(resolve, 10));
                    
                    try {
                        const img = await loadImage(item.previewUrl);
                        const enhance = state.batchEnhance || state.enhanceQuality;
                        // For batch, auto-detect watermarks if enabled
                        let regions = [];
                        if (state.watermarkRemovalEnabled) {
                            regions = detectWatermarks(img, state.detectionSensitivity);
                        }
                        const blob = await processImageToBlob(img, state.fitMode, state.outputPreset, enhance, regions);
                        
                        let suffix = '';
                        if (enhance) suffix += '-natgeo';
                        if (regions.length > 0) suffix += '-clean';
                        if (state.outputPreset === 'ULTRA_8K') suffix += '-8k.jpg';
                        else suffix += '-thumbnail.jpg';
                        
                        const fileName = item.file.name.replace(/\.[^/.]+$/, "") + suffix;
                        folder.file(fileName, blob);
                        successCount++;
                    } catch (err) {
                        console.error(`Failed: ${item.file.name}`, err);
                        failCount++;
                    }
                }
                
                if (failCount > 0) {
                    showToast(`${failCount} images failed to process`, 'warning');
                }
                
                btn.innerHTML = `
                    <div class="spinner w-4 h-4 border-2"></div>
                    <span>Generating ZIP...</span>
                `;
                
                const content = await zip.generateAsync({ type: "blob" });
                
                const url = URL.createObjectURL(content);
                const link = document.createElement('a');
                link.href = url;
                link.download = `framecraft-batch-${Date.now()}.zip`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                showToast(`ZIP generated with ${successCount} images`, 'success');
                
            } catch (err) {
                console.error("Batch processing failed", err);
                showToast("Failed to process batch. Try fewer images.", 'error');
            }
            
            state.isZipping = false;
            btn.innerHTML = originalContent;
        }

        function handleGenerateMetadata() {
            const metadata = generateMetadata();
            
            elements.generatedTitle.textContent = metadata.title;
            elements.generatedDescription.textContent = metadata.description;
            
            state.currentHashtags = metadata.hashtags;
            elements.generatedHashtags.innerHTML = metadata.hashtags.map(tag => `
                <span class="px-2 py-1 bg-indigo-900/50 text-indigo-200 text-xs rounded-full border border-indigo-800/50">
                    #${tag}
                </span>
            `).join('');
            
            elements.generateMetadataBtn.classList.add('hidden');
            elements.metadataResults.classList.remove('hidden');
        }

        function copyText(text) {
            navigator.clipboard.writeText(text).then(() => {
                showToast('Copied to clipboard', 'success');
            }).catch(() => {
                showToast('Copy failed', 'error');
            });
        }

        // ============ EVENT LISTENERS ============
        elements.addImagesBtn.addEventListener('click', () => elements.fileInput.click());
        
        elements.fileInput.addEventListener('change', (e) => {
            if (e.target.files && e.target.files.length > 0) {
                addFiles(e.target.files);
                e.target.value = '';
            }
        });
        
        elements.downloadAllBtn.addEventListener('click', downloadAll);
        elements.downloadCurrentBtn.addEventListener('click', downloadCurrent);
        
        elements.preset8k.addEventListener('click', () => {
            state.outputPreset = 'ULTRA_8K';
            updateUI();
            updatePreview();
        });
        
        elements.presetYT.addEventListener('click', () => {
            state.outputPreset = 'YT_THUMBNAIL';
            updateUI();
            updatePreview();
        });
        
        elements.fitBlur.addEventListener('click', () => {
            state.fitMode = FIT_MODES.CONTAIN_BLUR;
            updateUI();
            updatePreview();
        });
        
        elements.fitBlack.addEventListener('click', () => {
            state.fitMode = FIT_MODES.CONTAIN_BLACK;
            updateUI();
            updatePreview();
        });
        
        elements.fitCrop.addEventListener('click', () => {
            state.fitMode = FIT_MODES.COVER;
            updateUI();
            updatePreview();
        });
        
        elements.enhanceBtn.addEventListener('click', () => {
            state.enhanceQuality = !state.enhanceQuality;
            updateUI();
            updatePreview();
        });
        
        elements.batchEnhanceToggle.addEventListener('click', () => {
            state.batchEnhance = !state.batchEnhance;
            updateUI();
        });
        
        // Watermark toggle
        elements.watermarkToggle.addEventListener('click', () => {
            state.watermarkRemovalEnabled = !state.watermarkRemovalEnabled;
            state.watermarkRegions = [];
            state.manualSelectionMode = false;
            renderWatermarkRegions();
            updateUI();
        });
        
        // Sensitivity slider
        elements.sensitivitySlider.addEventListener('input', (e) => {
            state.detectionSensitivity = parseInt(e.target.value);
            elements.sensitivityValue.textContent = e.target.value;
        });
        
        // Detect watermarks button
        elements.detectWatermarksBtn.addEventListener('click', autoRemoveWatermarks);
        
        // Manual selection
        elements.manualSelectBtn.addEventListener('click', () => {
            state.manualSelectionMode = !state.manualSelectionMode;
            if (state.manualSelectionMode) {
                setupManualSelection();
            }
            updateUI();
        });
        
        // Clear regions
        elements.clearRegionsBtn.addEventListener('click', () => {
            state.watermarkRegions = [];
            renderWatermarkRegions();
            updateUI();
            elements.watermarkBadge.classList.add('hidden');
        });
        
        // Remove watermark button
        elements.removeWatermarkBtn.addEventListener('click', autoRemoveWatermarks);
        
        elements.generateMetadataBtn.addEventListener('click', handleGenerateMetadata);
        elements.regenerateBtn.addEventListener('click', handleGenerateMetadata);
        
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('copy-btn')) {
                const targetId = e.target.dataset.target;
                const text = document.getElementById(targetId).textContent;
                copyText(text);
            }
        });
        
        elements.copyHashtagsBtn.addEventListener('click', () => {
            const hashtagsText = state.currentHashtags.map(t => `#${t}`).join(' ');
            copyText(hashtagsText);
        });
        
        // Drag and Drop
        elements.dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            elements.dropZone.classList.add('dragover');
        });
        
        elements.dropZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            elements.dropZone.classList.remove('dragover');
        });
        
        elements.dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            elements.dropZone.classList.remove('dragover');
            
            const files = e.dataTransfer.files;
            if (files && files.length > 0) {
                const imageFiles = Array.from(files).filter(f => f.type.startsWith('image/'));
                if (imageFiles.length > 0) {
                    addFiles(imageFiles);
                }
            }
        });
        
        // Prevent default drag behavior on window
        window.addEventListener('dragover', (e) => e.preventDefault());
        window.addEventListener('drop', (e) => e.preventDefault());
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            state.batchItems.forEach(item => URL.revokeObjectURL(item.previewUrl));
            state.processingCache.clear();
            metadataCache.clear();
        });
        
        // Initial UI update
        updateUI();
    </script>
</body>
</html>
